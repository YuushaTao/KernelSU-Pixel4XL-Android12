int __fastcall ikcp_input(ikcpcb *kcp, const unsigned __int8 *data, int size)
{
  ikcpcb *v3; // r4
  RateCountEx *rcvRateCountPtr; // r5
  bool v7; // zf
  __int64 v8; // r0
  IQUEUEHEAD *p_snd_buf; // r9
  int v10; // r10
  int len; // r8
  int v12; // r10
  int v13; // r1
  int result; // r0
  IQUEUEHEAD *next; // r0
  IQUEUEHEAD *v16; // r1
  IQUEUEHEAD *v17; // r7
  IUINT32 *v18; // r8
  const unsigned __int8 *v19; // r6
  IUINT32 *v20; // r0
  IUINT32 v21; // r0
  IUINT64 *v22; // r6
  IUINT32 v23; // r5
  IUINT32 rcv_nxt; // r0
  IUINT32 rcv_wnd_const; // r1
  int logmask; // r0
  int v27; // r7
  IUINT32 v28; // r12
  IQUEUEHEAD *v29; // r0
  IQUEUEHEAD *v30; // r1
  IUINT32 ackcount; // r0
  unsigned int v32; // r2
  unsigned int v33; // r6
  size_t v34; // r0
  IUINT32 *v35; // r0
  IUINT32 *acklist; // r8
  IINT32 rx_srtt; // r2
  int v38; // r1
  bool v39; // nf
  int v40; // r12
  int v41; // r2
  int v42; // r2
  IUINT64 *v43; // r10
  int v44; // r8
  IUINT32 *v45; // r0
  IUINT32 i; // r1
  IUINT32 *v47; // r2
  IUINT32 *v48; // r7
  IUINT32 v49; // r7
  int v50; // r6
  IUINT32 interval_const; // r3
  unsigned int rx_minrto; // r1
  IQUEUEHEAD *v53; // r1
  __int64 v54; // r6
  size_t v55; // r0
  _DWORD *v56; // r0
  int v57; // r0
  IUINT32 v58; // r0
  IUINT32 v59; // r1
  IQUEUEHEAD **p_prev; // r2
  int v61; // r0
  IUINT32 v62; // r1
  IQUEUEHEAD *v63; // r0
  IQUEUEHEAD *v64; // r2
  IINT32 v65; // lr
  int v66; // r1
  int v67; // r12
  int v68; // r2
  IUINT64 *v69; // r10
  int v70; // r8
  int v71; // r6
  IUINT32 v72; // r3
  unsigned int v73; // r1
  IQUEUEHEAD *v74; // r1
  IUINT32 v75; // r5
  IQUEUEHEAD *v76; // r0
  IUINT32 v77; // r0
  IQUEUEHEAD *v78; // r1
  IUINT32 v79; // r0
  IUINT32 nrcv_que; // r2
  const unsigned __int8 *v81; // r12
  IQUEUEHEAD v82; // r6
  IQUEUEHEAD *prev; // r3
  IUINT32 v84; // r0
  IQUEUEHEAD *v85; // r2
  IQUEUEHEAD *v86; // r7
  ikcpcb *v87; // r3
  int v88; // r1
  __int64 v89; // r6
  unsigned int v90; // r1
  IUINT32 mss_const; // r5
  IUINT32 incr; // r8
  bool v93; // cf
  unsigned int v94; // r0
  int v95; // [sp+4h] [bp-C4h]
  IUINT32 snd_una; // [sp+34h] [bp-94h]
  int v97; // [sp+68h] [bp-60h]
  IUINT64 *v98; // [sp+6Ch] [bp-5Ch]
  IUINT32 tmpmaxack; // [sp+70h] [bp-58h]
  IQUEUEHEAD *p_rcv_buf; // [sp+74h] [bp-54h]
  IUINT32 ts; // [sp+78h] [bp-50h]
  const unsigned __int8 *v102; // [sp+7Ch] [bp-4Ch]
  const unsigned __int8 *v103; // [sp+7Ch] [bp-4Ch]
  int v104; // [sp+80h] [bp-48h]
  int frg; // [sp+84h] [bp-44h]
  unsigned int v106; // [sp+88h] [bp-40h]
  IUINT32 *p_snd_nxt; // [sp+8Ch] [bp-3Ch]
  int v108; // [sp+90h] [bp-38h]
  size_t v109; // [sp+94h] [bp-34h]
  IUINT32 _ts; // [sp+98h] [bp-30h]
  IUINT32 wnd; // [sp+9Ch] [bp-2Ch]
  int v112; // [sp+A0h] [bp-28h]
  int v113; // [sp+A4h] [bp-24h]
  IUINT32 cmd; // [sp+A4h] [bp-24h]
  int v115; // [sp+A8h] [bp-20h]

  v3 = kcp;
  rcvRateCountPtr = kcp->rcvRateCountPtr;
  v7 = rcvRateCountPtr == 0;
  if ( rcvRateCountPtr )
  {
    kcp = (ikcpcb *)kcp->getusec;
    v7 = kcp == 0;
  }
  if ( !v7 )
  {
    v8 = ((__int64 (*)(void))kcp)();
    j_SampleInsertEx(rcvRateCountPtr, HIDWORD(v8), size, size >> 31, v8, HIDWORD(v8));
  }
  if ( data && size >= 24 )
  {
    p_snd_buf = &v3->snd_buf;
    snd_una = v3->snd_una;
    p_rcv_buf = &v3->rcv_buf;
    p_snd_nxt = &v3->snd_nxt;
    v10 = 0;
    len = 0;
    v98 = maskarray;
    v97 = 0;
    tmpmaxack = 0;
    v115 = 0;
    ts = 0;
    while ( 1 )
    {
      if ( *(_DWORD *)data != v3->conv )
        return -1;
      v112 = v10;
      frg = data[5];                            // frg? 为0
      v12 = *((_DWORD *)data + 3);              // 不只知道是什么好像是0
      _ts = *((_DWORD *)data + 2);              // 一直变的数字
      wnd = *((unsigned __int16 *)data + 3);    // 0x200
      v106 = data[4];
      v113 = v106 & 0xF;                        // cmd? 为1
      if ( v113 == 2 )
      {
        v104 = *(_DWORD *)data;
        v115 = *((_DWORD *)data + 5);
        v112 = *((_DWORD *)data + 4);
        v13 = size - 24;
      }
      else                                      // 数据包?
      {
        len = *((_DWORD *)data + 5);            // size
        result = -2;
        v104 = *(_DWORD *)data;                 // conv
        v13 = size - 24;
        if ( size - 24 < len )
          return result;
        ts = *((_DWORD *)data + 4);             // ts
      }
      result = -3;
      if ( (unsigned __int8)(v113 - 1) > 3u )
        return result;
      v3->rmt_wnd = wnd;
      next = v3->snd_buf.next;
      v108 = v13;
      v16 = &v3->snd_buf;
      v109 = len;
      if ( next != p_snd_buf )
      {
        do
        {
          if ( (signed int)(v12 - (unsigned int)next[3].next) < 1 )
            break;
          v17 = next->next;
          v17->prev = next->prev;
          next->prev->next = v17;
          next->next = 0;
          next->prev = 0;
          if ( ikcp_free_hook )
            ((void (*)(void))ikcp_free_hook)();
          else
            free(next);
          --v3->nsnd_buf;
          next = v17;
        }
        while ( v17 != p_snd_buf );
        v16 = p_snd_buf->next;
      }
      v18 = p_snd_nxt;
      v19 = data + 24;
      v20 = p_snd_nxt;
      if ( v16 != p_snd_buf )
        v20 = (IUINT32 *)&v16[3];
      v21 = *v20;
      v3->snd_una = v21;
      if ( (unsigned __int8)v113 != 1 )
      {
        if ( (unsigned __int8)v113 == 3 )
        {
          v10 = v112;
          v3->probe |= 2u;
          if ( (v3->logmask & 0x40) != 0 )
            j_Internal_DebugLog_OutPut("SK_Base/ikcp.c", 1316, byte_18A8D5);
          len = v109;
        }
        else
        {
          v10 = v112;
          if ( (unsigned __int8)v113 == 2 )
          {
            if ( (v3->logmask & 0x20) != 0 )
            {
              v23 = _ts;
              v102 = v19;
              j_Internal_DebugLog_OutPut(
                "SK_Base/ikcp.c",
                952,
                "\x1B[1;32m[%u]=========sn=%u,mask:%llu,kcp->snd_una:%u=======\n\x1B[m",
                _ts,
                v95,
                v112,
                v115,
                v21);
              v21 = v3->snd_una;
              v22 = v98;
            }
            else
            {
              v102 = v19;
              v22 = v98;
              v23 = _ts;
            }
            v27 = 0;
            v28 = 0;
            if ( (int)(v23 - v21) >= 0 )
            {
              v28 = 0;
              v29 = &v3->snd_buf;
              if ( (int)(v23 - *p_snd_nxt) < 0 )
              {
                while ( 1 )
                {
                  v29 = v29->next;
                  if ( v29 == p_snd_buf )
                  {
LABEL_42:
                    v28 = 0;
                    goto LABEL_104;
                  }
                  v30 = v29[3].next;
                  if ( (IQUEUEHEAD *)v23 == v30 )
                    break;
                  if ( (int)(v23 - (_DWORD)v30) < 0 )
                    goto LABEL_42;
                }
                rx_srtt = v3->rx_srtt;
                v38 = v3->current - (unsigned int)v29[4].next;
                if ( rx_srtt )
                {
                  v40 = v38 - rx_srtt;
                  v39 = v38 - rx_srtt < 0;
                  v41 = 7 * rx_srtt;
                  if ( v39 )
                    v40 = -v40;
                  v42 = v41 + v38;
                  v43 = v22;
                  v38 = v42 / 8;
                  if ( v42 < 8 )
                    v38 = 1;
                  v44 = (3 * v3->rx_rttval + v40) / 4;
                }
                else
                {
                  v43 = v22;
                  v44 = v38 / 2;
                }
                v3->rx_rttval = v44;
                v50 = 8 * v44;
                v3->rx_srtt = v38;
                interval_const = v3->interval_const;
                if ( 2 * interval_const >= 8 * v44 )
                  v50 = 2 * interval_const;
                rx_minrto = v50 + v38;
                if ( v3->rx_minrto >= rx_minrto )
                  rx_minrto = v3->rx_minrto;
                if ( rx_minrto > 0xEA60 )
                  rx_minrto = 60000;
                v3->rx_rto = rx_minrto;
                v53 = v29->next;
                v53->prev = v29->prev;
                v29->prev->next = v53;
                v29->next = 0;
                v29->prev = 0;
                if ( ikcp_free_hook )
                  ikcp_free_hook(v29);
                else
                  free(v29);
                v22 = v43;
                v18 = p_snd_nxt;
                v28 = v23;
                --v3->nsnd_buf;
                v10 = v112;
              }
            }
LABEL_104:
            if ( v10 | v115 )
            {
              do
              {
                if ( v22[v27] & v10 | HIDWORD(v22[v27]) & v115 )
                {
                  v62 = v27 + v23;
                  if ( (int)(v27 + v23 - v3->snd_una) >= 0 )
                  {
                    v63 = &v3->snd_buf;
                    if ( (int)(v62 - *v18) < 0 )
                    {
                      do
                      {
                        v63 = v63->next;
                        if ( v63 == p_snd_buf )
                          break;
                        v64 = v63[3].next;
                        if ( (IQUEUEHEAD *)v62 == v64 )
                        {
                          if ( v28 < v62 )
                            v28 = v27 + v23;
                          v65 = v3->rx_srtt;
                          v66 = v3->current - (unsigned int)v63[4].next;
                          if ( v65 )
                          {
                            cmd = v28;
                            v67 = v66 - v65;
                            v68 = 7 * v65 + v66;
                            if ( v66 - v65 < 0 )
                              v67 = v65 - v66;
                            v69 = v22;
                            v66 = v68 / 8;
                            if ( v68 < 8 )
                              v66 = 1;
                            v70 = (3 * v3->rx_rttval + v67) / 4;
                          }
                          else
                          {
                            cmd = v28;
                            v69 = v22;
                            v70 = v66 / 2;
                          }
                          v3->rx_rttval = v70;
                          v71 = 8 * v70;
                          v3->rx_srtt = v66;
                          v72 = v3->interval_const;
                          if ( 2 * v72 >= 8 * v70 )
                            v71 = 2 * v72;
                          v73 = v71 + v66;
                          if ( v3->rx_minrto >= v73 )
                            v73 = v3->rx_minrto;
                          if ( v73 > 0xEA60 )
                            v73 = 60000;
                          v3->rx_rto = v73;
                          v74 = v63->next;
                          v74->prev = v63->prev;
                          v63->prev->next = v74;
                          v63->next = 0;
                          v63->prev = 0;
                          if ( ikcp_free_hook )
                            ikcp_free_hook(v63);
                          else
                            free(v63);
                          v22 = v69;
                          v18 = p_snd_nxt;
                          v10 = v112;
                          v28 = cmd;
                          --v3->nsnd_buf;
                          break;
                        }
                      }
                      while ( (int)(v62 - (_DWORD)v64) >= 0 );
                    }
                  }
                }
                ++v27;
              }
              while ( v27 != 64 );
            }
            else if ( (v3->logmask & 0x20) != 0 )
            {
              v75 = v28;
              j_Internal_DebugLog_OutPut("SK_Base/ikcp.c", 995, "\x1B[1;32m[%d]mask is 0\n\x1B[m");
              v28 = v75;
            }
            v76 = v3->snd_buf.next;
            p_snd_nxt = v18;
            v98 = v22;
            if ( v76 != p_snd_buf )
              v18 = (IUINT32 *)&v76[3];
            v3->snd_una = *v18;
            v77 = tmpmaxack;
            len = v109;
            if ( tmpmaxack < v28 )
              v77 = v28;
            tmpmaxack = v77;
            v97 = 1;
            goto LABEL_140;
          }
          logmask = v3->logmask;
          len = v109;
          if ( (unsigned __int8)v113 != 4 )
          {
            if ( (logmask & 0x10) != 0 )
              j_Internal_ErrorLog_OutPut(
                "SK_Base/ikcp.c",
                1328,
                "\x1B[0;32;31m[%u]uncrecognized command:%u\n\x1B[m",
                v3->conv,
                v113);
            return -3;
          }
          if ( (logmask & 0x80) != 0 )
            j_Internal_DebugLog_OutPut("SK_Base/ikcp.c", 1325, byte_18A91C, wnd);
        }
        goto LABEL_81;
      }
      rcv_nxt = v3->rcv_nxt;
      rcv_wnd_const = v3->rcv_wnd_const;
      len = v109;
      if ( (int)(_ts - rcv_nxt - rcv_wnd_const) >= 0 )
      {
        if ( (v3->logmask & 0x10) != 0 )
          j_Internal_DebugLog_OutPut(
            "SK_Base/ikcp.c",
            1307,
            "\x1B[1;32m[%u]recv sn [%u] is out of range[%u+%u]\n\x1B[m",
            _ts,
            rcv_nxt,
            rcv_wnd_const);
LABEL_80:
        v10 = v112;
        goto LABEL_81;
      }
      ackcount = v3->ackcount;
      v32 = 8;
      v103 = v19;
      if ( ackcount + 1 <= v3->ackblock )
      {
        acklist = v3->acklist;
      }
      else
      {
        do
        {
          v33 = v32;
          v93 = v32 >= ackcount + 1;
          v32 *= 2;
        }
        while ( !v93 );
        v34 = 8 * v33;
        if ( ikcp_malloc_hook )
          v35 = (IUINT32 *)ikcp_malloc_hook(v34);
        else
          v35 = (IUINT32 *)calloc(v34, 1u);
        acklist = v35;
        if ( !v35 )
        {
          v19 = v103;
          v49 = _ts;
          if ( (v3->logmask & 0x200) != 0 )
            j_Internal_ErrorLog_OutPut(
              "SK_Base/ikcp.c",
              1099,
              "\x1B[0;32;31m[%u]malloc memory  for acklist failed!!!\n\x1B[m");
          goto LABEL_77;
        }
        v45 = v3->acklist;
        if ( v45 )
        {
          for ( i = 0; i < v3->ackcount; v48[1] = v47[1] )
          {
            v47 = &v45[2 * i];
            acklist[2 * i] = *v47;
            v48 = &acklist[2 * i++];
          }
          if ( ikcp_free_hook )
            ikcp_free_hook(v45);
          else
            free(v45);
        }
        v3->acklist = acklist;
        v3->ackblock = v33;
        ackcount = v3->ackcount;
      }
      v49 = _ts;
      v19 = v103;
      acklist[2 * ackcount] = _ts;
      acklist[2 * ackcount + 1] = ts;
      ++v3->ackcount;
LABEL_77:
      len = v109;
      if ( (int)(v49 - v3->rcv_nxt) < 0 )
        goto LABEL_80;
      HIDWORD(v54) = v106 >> 4;
      v55 = v109 + 64;
      v102 = v19;
      if ( ikcp_malloc_hook )
        v56 = ikcp_malloc_hook(v55);
      else
        v56 = calloc(v55, 1u);
      LODWORD(v54) = v56;
      v56[2] = v104;
      *((_WORD *)v56 + 6) = BYTE4(v54);
      *((_WORD *)v56 + 7) = v113;
      v56[4] = frg;
      v56[5] = wnd;
      v56[6] = _ts;
      v56[7] = v12;
      v56[8] = ts;
      v56[9] = v109;
      if ( v109 )
        qmemcpy(v56 + 14, v102, v109);
      v58 = v3->rcv_nxt;
      v59 = v3->rcv_wnd_const;
      v10 = v112;
      if ( (int)(_ts - v58) < 0 || (p_prev = &v3->rcv_buf.prev, (int)(_ts - v58 - v59) >= 0) )
      {
        len = v109;
        if ( (v3->logmask & 0x10) != 0 )
          j_Internal_WarningLog_OutPut(
            "SK_Base/ikcp.c",
            1138,
            "\x1B[1;33m[%u]seg 's timestamp %u is not in range between `%u` and `%u`\n\x1B[m",
            _ts,
            v58,
            v59 + v58);
        if ( ikcp_free_hook )
          ikcp_free_hook((void *)v54);
        else
          free((void *)v54);
LABEL_140:
        v57 = v108;
        v19 = v102;
        goto LABEL_141;
      }
      while ( 1 )
      {
        HIDWORD(v54) = *p_prev;
        if ( *p_prev == p_rcv_buf )
        {
          HIDWORD(v54) = &v3->rcv_buf;
LABEL_97:
          *(_QWORD *)v54 = v54;
          *(_DWORD *)v54 = *(_DWORD *)HIDWORD(v54);
          *(_DWORD *)(*(_DWORD *)HIDWORD(v54) + 4) = v54;
          *(_DWORD *)HIDWORD(v54) = v54;
          ++v3->nrcv_buf;
          goto LABEL_144;
        }
        v61 = *(_DWORD *)(HIDWORD(v54) + 24);
        if ( _ts == v61 )
          break;
        p_prev = (IQUEUEHEAD **)(HIDWORD(v54) + 4);
        if ( (int)(_ts - v61) >= 1 )
          goto LABEL_97;
      }
      if ( (v3->logmask & 0x10) != 0 )
        j_Internal_WarningLog_OutPut("SK_Base/ikcp.c", 1160, "\x1B[1;33m[%u]seg 's timestamp %u is repeat\n\x1B[m", _ts);
      if ( ikcp_free_hook )
        ikcp_free_hook((void *)v54);
      else
        free((void *)v54);
LABEL_144:
      v19 = v102;
      v78 = p_rcv_buf->next;
      if ( p_rcv_buf != p_rcv_buf->next )
      {
        v79 = v3->rcv_nxt;
        do
        {
          if ( (IQUEUEHEAD *)v79 != v78[3].next )
            break;
          nrcv_que = v3->nrcv_que;
          if ( nrcv_que >= v3->rcv_wnd_const )
            break;
          v81 = v19;
          v82 = *v78;
          ++v79;
          v82.next->prev = v82.prev;
          v78->prev->next = v82.next;
          v78->prev = 0;
          v19 = v81;
          --v3->nrcv_buf;
          prev = v3->rcv_queue.prev;
          v78->next = &v3->rcv_queue;
          v78->prev = prev;
          v3->rcv_queue.prev->next = v78;
          v3->rcv_queue.prev = v78;
          v3->nrcv_que = nrcv_que + 1;
          v3->rcv_nxt = v79;
          v78 = v3->rcv_buf.next;
        }
        while ( p_rcv_buf != v78 );
      }
      len = v109;
LABEL_81:
      v57 = v108;
LABEL_141:
      size = v57 - len;
      data = &v19[len];
      if ( v57 - len <= 23 )
      {
        v84 = v3->snd_una;
        if ( v97 )
        {
          if ( (int)(tmpmaxack - v84) >= 0 && (int)(tmpmaxack - v3->snd_nxt) < 0 )
          {
            v85 = v3->snd_buf.next;
            if ( v85 != &v3->snd_buf )
            {
              do
              {
                v86 = v85[3].next;
                if ( (int)(tmpmaxack - (_DWORD)v86) < 0 )
                  break;
                v87 = (ikcpcb *)v85->next;
                if ( (IQUEUEHEAD *)tmpmaxack != v86 )
                  ++v85[6].next;
                v85 = (IQUEUEHEAD *)v87;
              }
              while ( v87 != (ikcpcb *)&v3->snd_buf );
            }
          }
        }
        v88 = v84 - snd_una;
        result = 0;
        if ( v88 >= 1 )
        {
          v89 = *(_QWORD *)&v3->rmt_wnd;
          if ( HIDWORD(v89) >= (unsigned int)v89 )
          {
            return 0;
          }
          else
          {
            if ( HIDWORD(v89) >= v3->ssthresh )
            {
              mss_const = v3->mss_const;
              incr = v3->incr;
              v93 = incr >= mss_const;
              if ( incr < mss_const )
                incr = v3->mss_const;
              if ( !v93 )
                v3->incr = mss_const;
              v90 = HIDWORD(v89) + 1;
              v94 = incr + (mss_const >> 4) + mss_const * mss_const / incr;
              v3->incr = v94;
              if ( (HIDWORD(v89) + 1) * mss_const > v94 )
                v90 = HIDWORD(v89);
              else
                v3->cwnd = v90;
            }
            else
            {
              v90 = HIDWORD(v89) + 1;
              v3->cwnd = HIDWORD(v89) + 1;
              mss_const = v3->mss_const;
              v3->incr += mss_const;
            }
            result = 0;
            if ( v90 > (unsigned int)v89 )
            {
              v3->cwnd = v89;
              v3->incr = mss_const * v89;
            }
          }
        }
        return result;
      }
    }
  }
  return -1;
}
